// TensorLogic Grammar for Pest Parser
// Based on Papers/実装/tensorlogic_grammar.md

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n" | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// ============================================================================
// Program Structure
// ============================================================================

program = { SOI ~ declaration* ~ main_block? ~ EOI }

declaration = {
    import_decl
    | tensor_decl
    | relation_decl
    | rule_decl
    | embedding_decl
    | function_decl
}

main_block = { "main" ~ "{" ~ statement* ~ "}" }

// ============================================================================
// Import Declarations
// ============================================================================

import_decl = { "import" ~ string_literal }

// ============================================================================
// Tensor Declarations
// ============================================================================

tensor_decl = { "tensor" ~ identifier ~ ":" ~ tensor_type ~ ("=" ~ tensor_expr)? }

tensor_type = { base_type ~ "[" ~ dimension_list ~ "]" ~ learnable? }

base_type = {
    "float16" | "int16" | "int32" | "int64" | "bool" | "complex16"
}

dimension_list = { dimension ~ ("," ~ dimension)* }

dimension = { integer | identifier | "?" }

learnable = { "learnable" | "frozen" }

// ============================================================================
// Relation Declarations
// ============================================================================

relation_decl = { "relation" ~ identifier ~ "(" ~ param_list? ~ ")" ~ embedding_spec? }

param_list = { param ~ ("," ~ param)* }

param = { identifier ~ ":" ~ entity_type }

entity_type = { "entity" | "concept" | tensor_type }

embedding_spec = { "embed" ~ tensor_type }

// ============================================================================
// Rule Declarations
// ============================================================================

rule_decl = { rule_head ~ "<-" ~ rule_body }

rule_head = { atom | tensor_equation }

rule_body = { body_term ~ ("," ~ body_term)* }

body_term = { atom | tensor_equation | constraint }

atom = { identifier ~ "(" ~ term_list? ~ ")" }

term_list = { term ~ ("," ~ term)* }

term = { identifier | constant | tensor_expr }

// ============================================================================
// Embedding Declarations
// ============================================================================

embedding_decl = {
    "embedding" ~ identifier ~ "{"
    ~ "entities" ~ ":" ~ entity_set
    ~ "dimension" ~ ":" ~ integer
    ~ ("init" ~ ":" ~ init_method)?
    ~ "}"
}

entity_set = { "{" ~ identifier_list ~ "}" | "auto" }

identifier_list = { identifier ~ ("," ~ identifier)* }

init_method = { "random" | "xavier" | "he" | "zeros" | "ones" }

// ============================================================================
// Function Declarations
// ============================================================================

function_decl = {
    "fn" ~ identifier ~ "(" ~ param_list? ~ ")"
    ~ "->" ~ return_type ~ "{" ~ statement* ~ "}"
}

return_type = { tensor_type | "void" }

// ============================================================================
// Tensor Expressions with Operator Precedence
// ============================================================================

// Top level: logical OR (lowest precedence)
tensor_expr = { logical_or_expr }

logical_or_expr = { logical_and_expr ~ (or_op ~ logical_and_expr)* }
or_op = { "||" }

logical_and_expr = { equality_expr ~ (and_op ~ equality_expr)* }
and_op = { "&&" }

equality_expr = { comparison_expr ~ (equality_op ~ comparison_expr)* }
equality_op = { "==" | "!=" }

comparison_expr = { additive_expr ~ (comparison_op ~ additive_expr)* }
comparison_op = { "<=" | ">=" | "<" | ">" }

additive_expr = { multiplicative_expr ~ (additive_op ~ multiplicative_expr)* }
additive_op = { "+" | "-" }

multiplicative_expr = { power_expr ~ (multiplicative_op ~ power_expr)* }
multiplicative_op = { "*" | "/" | "@" | "⊙" }

power_expr = { unary_expr ~ (power_op ~ unary_expr)* }
power_op = { "**" | "⊗" }

unary_expr = { unary_op ~ unary_expr | tensor_term }

tensor_term = {
    "(" ~ tensor_expr ~ ")"
    | tensor_index
    | embedding_lookup
    | einstein_sum
    | python_call
    | function_call
    | tensor_literal
    | string_literal
    | identifier
}

binary_op = {
    "||" | "&&"
    | "==" | "!=" | "<=" | ">=" | "<" | ">"
    | "**" | "⊗" | "⊙" | "@" | "*" | "/" | "+" | "-"
}

unary_op = {
    "inv" | "-" | "!"
}

einstein_sum = { "einsum" ~ "(" ~ string_literal ~ "," ~ tensor_list ~ ")" }

tensor_list = { tensor_expr ~ ("," ~ tensor_expr)* }

function_call = { identifier ~ "(" ~ tensor_list? ~ ")" }

tensor_index = { identifier ~ "[" ~ index_list ~ "]" }

index_list = { index_expr ~ ("," ~ index_expr)* }

index_expr = { integer | identifier | ":" }

embedding_lookup = { identifier ~ "[" ~ entity_ref ~ "]" }

entity_ref = { identifier | string_literal }

tensor_literal = { "[" ~ tensor_elements ~ "]" | scalar_literal }

tensor_elements = { tensor_element ~ ("," ~ tensor_element)* }

tensor_element = { number | tensor_literal | tensor_expr }

scalar_literal = { complex_number | number | boolean }

// ============================================================================
// Constraints
// ============================================================================

constraint = { constraint_term ~ (logical_op ~ constraint_term)* }

constraint_term = {
    "not" ~ constraint_term
    | "(" ~ constraint ~ ")"
    | tensor_constraint
    | comparison
}

comparison = { tensor_expr ~ comp_op ~ tensor_expr }

comp_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" | "≈" }

tensor_constraint = {
    "shape" ~ "(" ~ tensor_expr ~ ")" ~ "==" ~ shape_spec
    | "rank" ~ "(" ~ tensor_expr ~ ")" ~ comp_op ~ integer
    | "norm" ~ "(" ~ tensor_expr ~ ")" ~ comp_op ~ number
}

shape_spec = { "[" ~ dimension_list ~ "]" }

logical_op = { "and" | "or" }

// ============================================================================
// Tensor Equations
// ============================================================================

tensor_equation = { tensor_expr ~ eq_type ~ tensor_expr }

eq_type = { ":=" | "~" | "=" }

// ============================================================================
// Statements
// ============================================================================

statement = {
    let_statement
    | break_statement
    | return_statement
    | tensor_decl
    | assignment
    | query              // Try query before fact_assertion (query is more specific with ? suffix)
    | fact_assertion
    | tensor_equation
    | python_import
    | function_call
    | inference_call
    | learning_call
    | control_flow
}

break_statement = { "break" }

return_statement = { "return" ~ tensor_expr? }

let_statement = { "let" ~ identifier ~ "=" ~ tensor_expr }

assignment = { identifier ~ ":=" ~ tensor_expr }

fact_assertion = { atom }

query = { atom ~ "?" ~ ("where" ~ constraint_list)? }

// Note: query uses ? suffix for distinction
// fact_assertion is just an atom (semantic analysis determines if it's a fact vs function call)
// These should be checked before tensor_equation and function_call in the statement rule

constraint_list = { constraint ~ ("," ~ constraint)* }

inference_call = { "infer" ~ (inference_block | (inference_method ~ query)) }

inference_block = { "{" ~ inference_item* ~ "}" }

inference_item = { inference_method ~ query }

inference_method = { "forward" | "backward" | "gradient" | "symbolic" }

learning_call = { "learn" ~ "{" ~ learning_spec ~ "}" }

learning_spec = {
    statement*
    ~ "objective" ~ ":" ~ tensor_expr ~ ","
    ~ "optimizer" ~ ":" ~ optimizer_spec ~ ","
    ~ "epochs" ~ ":" ~ integer
    ~ ("," ~ "scheduler" ~ ":" ~ scheduler_spec)?
}

optimizer_spec = { identifier ~ "(" ~ optimizer_params? ~ ")" }

optimizer_params = { optimizer_param ~ ("," ~ optimizer_param)* }

optimizer_param = { identifier ~ ("=" | ":") ~ number }

scheduler_spec = { identifier ~ "(" ~ scheduler_params? ~ ")" }

scheduler_params = { scheduler_param ~ ("," ~ scheduler_param)* }

scheduler_param = { identifier ~ ("=" | ":") ~ number }

// ============================================================================
// Control Flow
// ============================================================================

control_flow = { if_statement | for_statement | while_statement | loop_statement }

if_statement = {
    "if" ~ condition ~ "{" ~ statement* ~ "}"
    ~ ("else" ~ "{" ~ statement* ~ "}")?
}

condition = { constraint | tensor_expr }

for_statement = {
    "for" ~ identifier ~ "in" ~ iterable ~ "{" ~ statement* ~ "}"
}

iterable = { range_expr | entity_set | tensor_expr }

range_expr = { "range" ~ "(" ~ integer ~ ")" }

while_statement = { "while" ~ condition ~ "{" ~ statement* ~ "}" }

loop_statement = { "loop" ~ "{" ~ statement* ~ "}" }

// ============================================================================
// Literals and Identifiers
// ============================================================================

constant = { number | string_literal | boolean }

number = @{ "-"? ~ (float | integer) }

integer = @{ ASCII_DIGIT+ }

float = @{
    ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ ~ exponent?
}

exponent = @{ ("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+ }

boolean = { "true" | "false" }

complex_number = { number ~ ("+" | "-") ~ number ~ "i" }

string_literal = @{ "\"" ~ (!"\"" ~ (escape_sequence | ANY))* ~ "\"" }

escape_sequence = @{ "\\\\" | "\\\"" | "\\n" | "\\t" | "\\r" }

// Identifier: Simple rule since lexer handles keyword distinction
// The lexer ensures keywords are not parsed as identifiers
// Identifiers - any word that is not a keyword
// Must check that the complete word is not a reserved keyword
identifier = @{
    !(
        (
            "tensor" | "relation" | "rule" | "fn" | "main"
            | "learnable" | "frozen" | "entity" | "concept" | "embed"
            | "einsum" | "infer" | "learn"
            | "forward" | "backward" | "gradient" | "symbolic"
            | "if" | "else" | "for" | "while" | "loop" | "break" | "return" | "in" | "range"
            | "let" | "true" | "false" | "not" | "and" | "or"
            | "objective" | "optimizer" | "epochs" | "auto"
            | "void"
            | "float16" | "int16" | "int32" | "int64" | "bool" | "complex16"
            | "python" | "import" | "as"
        )
        ~ !(ASCII_ALPHANUMERIC | "_")
    )
    ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*
}

// Helper: Keywords - must be complete words (not followed by alphanumeric or underscore)
keyword = @{
    (
        "tensor" | "relation" | "rule" | "fn" | "main"
        | "learnable" | "frozen" | "entity" | "concept" | "embed"
        | "einsum" | "infer" | "learn"
        | "forward" | "backward" | "gradient" | "symbolic"
        | "if" | "else" | "for" | "while" | "loop" | "break" | "return" | "in" | "range"
        | "let" | "true" | "false" | "not" | "and" | "or"
        | "objective" | "optimizer" | "epochs" | "auto"
        | "void"
        | "float16" | "int16" | "int32" | "int64" | "bool" | "complex16"
        | "python" | "import" | "as"
    ) ~ !(ASCII_ALPHANUMERIC | "_")
}

// Legacy reserved_keyword for backward compatibility (if needed elsewhere)
reserved_keyword = {
    "tensor" | "relation" | "rule" | "fn" | "main"
    | "learnable" | "frozen" | "entity" | "concept" | "embed"
    | "einsum" | "infer" | "learn"
    | "forward" | "backward" | "gradient" | "symbolic"
    | "if" | "else" | "for" | "while" | "loop" | "break" | "return" | "in" | "range"
    | "let" | "true" | "false" | "not" | "and" | "or"
    | "objective" | "optimizer" | "epochs" | "auto"
    | "void"
    | "float16" | "int16" | "int32" | "int64" | "bool" | "complex16"
    | "python" | "import" | "as"
}

// ============================================================================
// Python Integration
// ============================================================================

// Python import: python import module [as alias]
python_import = { "python" ~ "import" ~ python_module ~ ("as" ~ identifier)? }

python_module = @{ identifier ~ ("." ~ identifier)* }

// Python function call: python.call("function_name", args)
python_call = { "python" ~ "." ~ "call" ~ "(" ~ string_literal ~ ("," ~ tensor_list)? ~ ")" }
