// TensorLogic Grammar for Pest Parser
// Based on Papers/実装/tensorlogic_grammar.md

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n" | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// ============================================================================
// Program Structure
// ============================================================================

program = { SOI ~ declaration* ~ main_block? ~ test_block* ~ bench_block* ~ EOI }

declaration = {
    import_decl
    | entity_decl
    | tensor_decl
    | relation_decl
    | rule_decl
    | relation_embedding_decl
    | embedding_decl
    | function_decl
    | struct_decl
    | impl_block
}

main_block = { "main" ~ "{" ~ statement* ~ "}" }

test_block = { "test" ~ identifier ~ "{" ~ statement* ~ "}" }

bench_block = { "bench" ~ identifier ~ "{" ~ statement* ~ "}" }

// ============================================================================
// Import Declarations
// ============================================================================

import_decl = { "import" ~ string_literal }

// ============================================================================
// Entity Declarations
// ============================================================================

entity_decl = { "entity" ~ identifier ~ ("=" ~ "{" ~ entity_list ~ "}")? }

entity_list = { identifier ~ ("," ~ identifier)* }

// ============================================================================
// Tensor Declarations
// ============================================================================

tensor_decl = { "tensor" ~ identifier ~ ":" ~ tensor_type ~ ("=" ~ tensor_expr)? }

tensor_type = { base_type ~ "[" ~ dimension_list ~ "]" ~ learnable? }

base_type = {
    "float32" | "float16" | "int16" | "int32" | "int64" | "bool" | "complex16"
}

scalar_type = {
    "int" | "float" | "bool" | "string"
}

dimension_list = { dimension ~ ("," ~ dimension)* }

dimension = { integer | identifier | "?" }

learnable = { "learnable" | "frozen" }

// ============================================================================
// Relation Declarations
// ============================================================================

relation_decl = { "relation" ~ identifier ~ "(" ~ param_list? ~ ")" ~ embedding_spec? }

param_list = { param ~ ("," ~ param)* }

param = { identifier ~ ":" ~ entity_type }

entity_type = {
    "entity"      // Generic entity type
  | "concept"     // Generic concept type
  | tensor_type   // Tensor type (must be before scalar_type and identifier to match correctly)
  | scalar_type   // Scalar types (int, float, bool, string)
  | struct_type   // Struct type
  | identifier    // Named entity type (e.g., Person, City)
}

embedding_spec = { "embed" ~ tensor_type }

// ============================================================================
// Rule Declarations
// ============================================================================

rule_decl = { rule_head ~ "<-" ~ rule_body }

rule_head = { atom | tensor_equation }

rule_body = { body_term ~ ("," ~ body_term)* }

body_term = { atom | tensor_equation | constraint }

atom = { identifier ~ "(" ~ term_list? ~ ")" }

term_list = { term ~ ("," ~ term)* }

term = { identifier | constant | tensor_expr }

// ============================================================================
// Embedding Declarations
// ============================================================================

embedding_decl = {
    "embedding" ~ identifier ~ "{"
    ~ "entities" ~ ":" ~ entity_set
    ~ "dimension" ~ ":" ~ integer
    ~ ("init" ~ ":" ~ init_method)?
    ~ "}"
}

relation_embedding_decl = {
    "relation_embedding" ~ identifier ~ "{"
    ~ "relations" ~ ":" ~ relation_set
    ~ "dimension" ~ ":" ~ integer
    ~ ("init" ~ ":" ~ init_method)?
    ~ "}"
}

entity_set = { "{" ~ identifier_list ~ "}" | "auto" | identifier }

relation_set = { "{" ~ identifier_list ~ "}" | "all" }

identifier_list = { identifier ~ ("," ~ identifier)* }

init_method = { "random" | "xavier" | "he" | "zeros" | "ones" }

// ============================================================================
// Function Declarations
// ============================================================================

function_decl = {
    "fn" ~ identifier ~ "(" ~ param_list? ~ ")"
    ~ "->" ~ return_type ~ "{" ~ statement* ~ "}"
}

return_type = { tensor_type | scalar_type | struct_type | "void" }

// ============================================================================
// Struct Declarations
// ============================================================================

struct_decl = {
    "struct" ~ identifier ~ type_params? ~ "{" ~ field_list ~ "}"
}

type_params = { "<" ~ type_param_list ~ ">" }

type_param_list = { identifier ~ ("," ~ identifier)* }

field_list = { (field ~ ","?)* }

field = { identifier ~ ":" ~ field_type ~ learnable? }

field_type = {
    tensor_type
    | scalar_type
    | struct_type
    | identifier  // Type parameter reference
}

struct_type = { identifier ~ ("<" ~ type_arg_list ~ ">")? }

type_arg_list = { type_arg ~ ("," ~ type_arg)* }

type_arg = { tensor_type | scalar_type | struct_type }

// ============================================================================
// Impl Blocks
// ============================================================================

impl_block = {
    "impl" ~ type_params? ~ trait_impl_for? ~ struct_type ~ "{" ~ method_decl* ~ "}"
}

// Optional "TraitName for" part (e.g., "Drop for")
trait_impl_for = { identifier ~ "for" }

method_decl = {
    "fn" ~ identifier ~ "(" ~ method_param_list? ~ ")"
    ~ ("->" ~ return_type)? ~ "{" ~ statement* ~ "}"
}

method_param_list = { method_param ~ ("," ~ method_param)* }

method_param = { "self" | param }

// ============================================================================
// Tensor Expressions with Operator Precedence
// ============================================================================

// Top level: logical OR (lowest precedence)
tensor_expr = { logical_or_expr }

logical_or_expr = { logical_and_expr ~ (or_op ~ logical_and_expr)* }
or_op = { "||" }

logical_and_expr = { equality_expr ~ (and_op ~ equality_expr)* }
and_op = { "&&" }

equality_expr = { comparison_expr ~ (equality_op ~ comparison_expr)* }
equality_op = { "==" | "!=" }

comparison_expr = { cast_expr ~ (comparison_op ~ cast_expr)* }
comparison_op = { "<=" | ">=" | "<" | ">" }

// Type cast expression: expr as type
cast_expr = { additive_expr ~ (as_op ~ cast_type)? }
as_op = { "as" }
cast_type = { "f32" | "f64" | "i32" | "i64" | "int" | "float" }

additive_expr = { multiplicative_expr ~ (additive_op ~ multiplicative_expr)* }
additive_op = { "+" | "-" }

multiplicative_expr = { power_expr ~ (multiplicative_op ~ power_expr)* }
multiplicative_op = { "*" | "/" | "%" | "@" | "⊙" }

power_expr = { unary_expr ~ (power_op ~ unary_expr)* }
power_op = { "**" | "⊗" }

unary_expr = { unary_op ~ unary_expr | tensor_term }

tensor_term = {
    postfix_expr
    | "(" ~ tensor_expr ~ ")"
    | match_expr
    | embedding_lookup
    | einstein_sum
    | python_call
    | struct_literal
    | tensor_literal
    | string_literal
}

// Postfix expressions: function calls and indexing
postfix_expr = {
    primary_expr ~ postfix_op*
}

primary_expr = {
    associated_call
    | function_call
    | identifier
}

postfix_op = {
    method_call
    | property_access
    | index_access
}

method_call = {
    "." ~ identifier ~ "(" ~ tensor_list? ~ ")"
}

property_access = {
    "." ~ identifier
}

index_access = {
    "[" ~ index_list ~ "]"
}

binary_op = {
    "||" | "&&"
    | "==" | "!=" | "<=" | ">=" | "<" | ">"
    | "**" | "⊗" | "⊙" | "@" | "*" | "/" | "%" | "+" | "-"
}

unary_op = {
    "inv" | "-" | "!"
}

einstein_sum = { "einsum" ~ "(" ~ string_literal ~ "," ~ tensor_list ~ ")" }

tensor_list = { tensor_expr ~ ("," ~ tensor_expr)* }

function_call = { (type_namespace ~ "::")? ~ identifier ~ "(" ~ tensor_list? ~ ")" }

type_namespace = { "Tensor" | "f16" | "f32" | "KVCache" }

associated_call = { struct_type ~ "::" ~ identifier ~ "(" ~ tensor_list? ~ ")" }

struct_literal = { struct_type ~ "{" ~ field_init_list? ~ "}" }

field_init_list = { field_init ~ ("," ~ field_init)* ~ ","? }

field_init = { identifier ~ ":" ~ tensor_expr }

// tensor_index is now handled by postfix_expr
// tensor_index = { identifier ~ "[" ~ index_list ~ "]" }

index_list = { index_expr ~ ("," ~ index_expr)* }

index_expr = { integer | identifier | ":" }

embedding_lookup = { identifier ~ "[" ~ entity_ref ~ "]" }

entity_ref = { identifier | string_literal }

tensor_literal = { "[" ~ tensor_elements? ~ "]" | scalar_literal }

tensor_elements = { tensor_element ~ ("," ~ tensor_element)* }

tensor_element = { number | tensor_literal | tensor_expr }

scalar_literal = { complex_number | number | boolean }

// ============================================================================
// Pattern Matching
// ============================================================================

match_expr = { "match" ~ tensor_expr ~ "{" ~ match_arm ~ ("," ~ match_arm)* ~ ","? ~ "}" }

match_arm = { pattern ~ ("if" ~ tensor_expr)? ~ "=>" ~ tensor_expr }

pattern = {
    pattern_or
}

pattern_or = { pattern_term ~ ("|" ~ pattern_term)* }

pattern_term = {
    wildcard_pattern
    | number_pattern
    | boolean_pattern
    | string_pattern
    | tuple_pattern
    | struct_pattern
    | variable_pattern
}

wildcard_pattern = { "_" }

number_pattern = { number }

boolean_pattern = { boolean }

string_pattern = { string_literal }

tuple_pattern = { "(" ~ pattern ~ ("," ~ pattern)* ~ ")" }

struct_pattern = { struct_type ~ "{" ~ field_pattern_list? ~ "}" }

field_pattern_list = { field_pattern ~ ("," ~ field_pattern)* ~ ","? }

field_pattern = { identifier ~ ":" ~ pattern }

variable_pattern = { identifier }

// ============================================================================
// Constraints
// ============================================================================

constraint = { constraint_term ~ (logical_op ~ constraint_term)* }

constraint_term = {
    "not" ~ constraint_term
    | "(" ~ constraint ~ ")"
    | tensor_constraint
    | comparison
}

comparison = { tensor_expr ~ comp_op ~ tensor_expr }

comp_op = { "==" | "!=" | "<=" | ">=" | "<" | ">" | "≈" }

tensor_constraint = {
    "shape" ~ "(" ~ tensor_expr ~ ")" ~ "==" ~ shape_spec
    | "rank" ~ "(" ~ tensor_expr ~ ")" ~ comp_op ~ integer
    | "norm" ~ "(" ~ tensor_expr ~ ")" ~ comp_op ~ number
}

shape_spec = { "[" ~ dimension_list ~ "]" }

logical_op = { "and" | "or" }

// ============================================================================
// Tensor Equations
// ============================================================================

tensor_equation = { tensor_expr ~ eq_type ~ tensor_expr }

eq_type = { "~" }

// ============================================================================
// Statements
// ============================================================================

statement = {
    let_statement
    | break_statement
    | return_statement
    | panic_statement
    | tensor_decl
    | assignment
    | query              // Try query before fact_assertion (query is more specific with ? suffix)
    | fact_assertion
    | tensor_equation
    | python_import
    | function_call
    | inference_call
    | learning_call
    | with_block
    | control_flow
    | block_statement
    | tensor_expr        // Allow expressions as statements (for method calls like cache.set(...))
}

block_statement = { "{" ~ statement* ~ "}" }

break_statement = { "break" }

return_statement = { "return" ~ tensor_expr? }

panic_statement = { "panic" ~ "(" ~ format_args ~ ")" }

format_args = { string_literal ~ ("," ~ tensor_expr)* }

let_statement = { "let" ~ identifier ~ "=" ~ tensor_expr }

assignment = { identifier ~ "=" ~ tensor_expr }

fact_assertion = { atom }

query = { atom ~ "?" ~ ("where" ~ constraint_list)? }

// Note: query uses ? suffix for distinction
// fact_assertion is just an atom (semantic analysis determines if it's a fact vs function call)
// These should be checked before tensor_equation and function_call in the statement rule

constraint_list = { constraint ~ ("," ~ constraint)* }

inference_call = { "infer" ~ (inference_block | (inference_method ~ query)) }

inference_block = { "{" ~ inference_item* ~ "}" }

inference_item = { inference_method ~ query }

inference_method = { "forward" | "backward" | "gradient" | "symbolic" }

learning_call = { "learn" ~ "{" ~ learning_spec ~ "}" }

learning_spec = {
    statement*
    ~ "objective" ~ ":" ~ tensor_expr ~ ","
    ~ "optimizer" ~ ":" ~ optimizer_spec ~ ","
    ~ "epochs" ~ ":" ~ integer
    ~ ("," ~ "scheduler" ~ ":" ~ scheduler_spec)?
}

optimizer_spec = { identifier ~ "(" ~ optimizer_params? ~ ")" }

optimizer_params = { optimizer_param ~ ("," ~ optimizer_param)* }

optimizer_param = { identifier ~ ("=" | ":") ~ number }

scheduler_spec = { identifier ~ "(" ~ scheduler_params? ~ ")" }

scheduler_params = { scheduler_param ~ ("," ~ scheduler_param)* }

scheduler_param = { identifier ~ ("=" | ":") ~ number }

// ============================================================================
// With Block
// ============================================================================

with_block = { "with" ~ identifier ~ "{" ~ statement* ~ "}" }

// ============================================================================
// Control Flow
// ============================================================================

control_flow = { if_statement | for_statement | while_statement | loop_statement }

if_statement = {
    "if" ~ condition ~ "{" ~ statement* ~ "}"
    ~ ("else" ~ "{" ~ statement* ~ "}")?
}

condition = { tensor_expr | constraint }

for_statement = {
    "for" ~ identifier ~ "in" ~ iterable ~ "{" ~ statement* ~ "}"
}

// Iterable can be any tensor expression or an entity set
// Iterator trait checking happens at parse time
iterable = { tensor_expr | entity_set }

while_statement = { "while" ~ condition ~ "{" ~ statement* ~ "}" }

loop_statement = { "loop" ~ "{" ~ statement* ~ "}" }

// ============================================================================
// Literals and Identifiers
// ============================================================================

constant = { number | string_literal | boolean }

number = @{ "-"? ~ (float | integer) }

integer = @{ ASCII_DIGIT+ }

float = @{
    ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ ~ exponent?
}

exponent = @{ ("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+ }

boolean = { "true" | "false" }

complex_number = { number ~ ("+" | "-") ~ number ~ "i" }

string_literal = @{ "\"" ~ (!"\"" ~ (escape_sequence | ANY))* ~ "\"" }

escape_sequence = @{ "\\\\" | "\\\"" | "\\n" | "\\t" | "\\r" }

// Identifier: Simple rule since lexer handles keyword distinction
// The lexer ensures keywords are not parsed as identifiers
// Identifiers - any word that is not a keyword
// Must check that the complete word is not a reserved keyword
identifier = @{
    !(
        (
            "tensor" | "relation" | "rule" | "fn" | "main"
            | "learnable" | "frozen" | "entity" | "concept" | "embed"
            | "einsum" | "infer" | "learn"
            | "forward" | "backward" | "gradient" | "symbolic"
            | "if" | "else" | "for" | "while" | "loop" | "break" | "return" | "in" | "range"
            | "let" | "true" | "false" | "not" | "and" | "or"
            | "objective" | "optimizer" | "epochs" | "auto"
            | "void"
            | "float32" | "float16" | "int16" | "int32" | "int64" | "bool" | "complex16"
            | "python" | "import" | "as" | "match"
        )
        ~ !(ASCII_ALPHANUMERIC | "_")
    )
    ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")*
}

// Helper: Keywords - must be complete words (not followed by alphanumeric or underscore)
keyword = @{
    (
        "tensor" | "relation" | "rule" | "fn" | "main"
        | "learnable" | "frozen" | "entity" | "concept" | "embed"
        | "einsum" | "infer" | "learn"
        | "forward" | "backward" | "gradient" | "symbolic"
        | "if" | "else" | "for" | "while" | "loop" | "break" | "return" | "in" | "range"
        | "let" | "true" | "false" | "not" | "and" | "or"
        | "objective" | "optimizer" | "epochs" | "auto"
        | "void"
        | "float32" | "float16" | "int16" | "int32" | "int64" | "bool" | "complex16"
        | "python" | "import" | "as" | "match"
    ) ~ !(ASCII_ALPHANUMERIC | "_")
}

// Legacy reserved_keyword for backward compatibility (if needed elsewhere)
reserved_keyword = {
    "tensor" | "relation" | "rule" | "fn" | "main"
    | "learnable" | "frozen" | "entity" | "concept" | "embed"
    | "einsum" | "infer" | "learn"
    | "forward" | "backward" | "gradient" | "symbolic"
    | "if" | "else" | "for" | "while" | "loop" | "break" | "return" | "in" | "range"
    | "let" | "true" | "false" | "not" | "and" | "or"
    | "objective" | "optimizer" | "epochs" | "auto"
    | "void"
    | "float32" | "float16" | "int16" | "int32" | "int64" | "bool" | "complex16"
    | "python" | "import" | "as" | "match"
}

// ============================================================================
// Python Integration
// ============================================================================

// Python import: python import module [as alias]
python_import = { "python" ~ "import" ~ python_module ~ ("as" ~ identifier)? }

python_module = @{ identifier ~ ("." ~ identifier)* }

// Python function call: python.call("function_name", args)
python_call = { "python" ~ "." ~ "call" ~ "(" ~ string_literal ~ ("," ~ tensor_list)? ~ ")" }
